#!/bin/bash

NAME=$0
ANALYZER_DIR="analyzers"
DIR="$(dirname "$(readlink -f "$NAME")")/"
STORE_C_FILE=false
STORE_LOGS=false
GENERATE_C_FILE=true
PARAM_REGEX=""
PROPERTY_FILE=""
REGEX_MODE="none"
TIMEOUT_DURATION="3m"
TMP_PATH="/tmp/""$ANALYZER_DIR"

export STORE_LOGS

red='\e[0;31m'
color='\e[0;32m'
NC='\e[0m' # No Color

help() {
    printf "\nUsage: %s [ options ] \n\n" "$NAME" >&2
    cat >&2 << EOF

    -c, --store-c-files
		enables storing C source files generated by Csmith.

    -f <file>, --file <file>
		input C file to verificate.
		<file> must be a correct C source code.
		if entered iterations is set to 1
    
    -i <number>, --iterations <number>
		sets <number> of iterations calling verification of generated C file.
		(set to 1 by default)
		if set to inf, program will continue till terminated

    -l, --store-log-files
		enables storing error/log files of analyzer stderr output.

    -r, --regex | -n, --neg-regex
		finds in analyzers folder only analyzers that match to the given regular expresion.
		format of regular expresion is 'your_regex'
		neg-regex is inverted, runs only analyzers that do not match to given expresion.

	-t <time>, --timeout <time>
		limits lenght of the verification run above single analyzer.
		inputed <time> is in format of decimal mumber, unit can be specified at the end of the number
		default is seconds
		default time limit is set to 3 minutes

    Output of program is printed result od verification by each of called analyzer.
    Format of output is " Analyzer ["name_of_analyzer"] result: "RESULT" " or eventually with logs
    storing turned on   " Analyzer ["name_of_analyzer"] result: "RESULT" logs: "PATH_TO_LOG" ".

    The verification RESULT is TRUE, FALSE, or UNKNOWN. All other information will be printed to error
    log stored in log file (must be nenabled by --store-log-files to)
    
    Memory option (-m64) for 64bit OS is used as default.
    
EOF
    exit 1
}


# @param 1: C source code to be verified 
check_file() {
	local source="$1"
	local property_file="$2"

    for a in $( find $DIR$ANALYZER_DIR -type f)
    do
    	ANALYZER=$(basename "$a")

		if [[ ("$REGEX_MODE" == "neg" && "$ANALYZER" =~ "$PARAM_N_REGEX") || ("$REGEX_MODE" == "norm" && ! "$ANALYZER" =~ "$PARAM_REGEX") ]] ; then
			#echo "ANALYZER [$ANALYZER] skipped";
			continue
		fi   
	
        if [ ! -x "$DIR$ANALYZER_DIR/$ANALYZER" ]; then
            echo "ANALYZER is not executable file: $ANALYZER" >&2; continue
        fi
        
        STDERR="$(mktemp '/tmp/'"$ANALYZER_DIR/$ANALYZER"'_tmp.XXXXXX.log')"
       
        RESULT=$(timeout $TIMEOUT_DURATION ./$ANALYZER_DIR/$ANALYZER "$source" "$property_file"  2> "$STDERR")
        if [[ "$?" == "124" || "$?" == "137" ]]; then
	    	RESULT="${red}TIMEOUT${NC}"
        fi
        
        if [ "$STORE_LOGS" == true ]; then
	    	echo -e "ANALYZER [$ANALYZER] result: ${color}$RESULT${NC} logs: $STDERR"
		else
	    	echo -e "ANALYZER [$ANALYZER] result: ${color}$RESULT${NC}"
	    	rm -f "$STDERR"
        fi

    done
}

regex() {
	re='^[-].*+$'
	if [[ $1 =~ $re ]] ; then
		echo "param regex needs regular expression as next argument" >&2; exit 0
	fi
}

main() {

iterations=1

	if [ $# -gt 0 ]; then
	
		if [[ "$1" == "--help" || "$1" == "-h" ]]; then
		    help; exit 1
		else
			
			ARGS=$(getopt -o cli:f:r:n:t:p: -l "store-c-files,store-log-files,iterations:,file:,regex:,neg-regex:,timeout:,-property-file:" -n "$NAME" -- "$@")
			if test $? -ne 0; then
				echo "Error in parameters" >&2; exit 0
			fi
		
			eval set -- "$ARGS"
		
			while true; do
				case "$1" in
				-c|--store-c-files)  STORE_C_FILE=true
				    echo "C codes will be stored."; shift;;
				-l|--store-log-files)  STORE_LOGS=true
				    echo "LOGs will be stored."; shift;;
				-f|--file)  
				    INPUT_C_FILE=$2
				    GENERATE_C_FILE=false
				    STORE_C_FILE=true
				    if [[ -s $INPUT_C_FILE && ! -d $INPUT_C_FILE ]]; then
				    	echo "C file inputed."  
				    else
				    	echo "Wrong input file." >&2; exit 0
				    	exit 1
				    fi
				    shift 2;;
				-i|--iterations) 
				    local re='^[0-9]+$'
				    if [[ "$2" == "inf" ]] ; then
						iterations="inf"
						echo "inf"
				    elif ! [[ $2 =~ $re ]] ; then
						echo "Wrong number of iterations or not a number" >&2; exit 0
				    else
						iterations=$2; 
				    fi
				    shift 2;;
				-n|--neg-regex)
				    if [[ "$REGEX_MODE" == "none" ]] ; then
						REGEX_MODE="neg"
						regex "$2" #call of function to handle the regex param.
				    else
						echo "Only one regex mode supported. Use --regex or --neg-regex not both." >&2; exit 0
				    fi
				    PARAM_N_REGEX="$2"
				    shift 2;;
				-p|--property-file)

					#TODO: syntax check

					PROPERTY_FILE="$2"

					if [ ! -e "$PROPERTY_FILE" ]; then
						echo -e "Property file \"$PROPERTY_FILE\" doesn't exist.\nFile will be generated." >&2
						PROPERTY_FILE=""
					fi
					

					shift 2;;
				-r|--regex)
				    if [[ "$REGEX_MODE" == "none" ]] ; then
						REGEX_MODE="norm"
						regex "$2" #call of function to handle the regex param.
				    else
						echo "Only one regex mode supported. Use --regex or --neg-regex not both." >&2; exit 0
				    fi
				    PARAM_REGEX="$2"
				    shift 2;;
				-t|--timeout)
				    local re='^[0-9]+[smhd]|^[0-9]+$'
				    if ! [[ $2 =~ $re ]] ; then
						echo "Wrong timeout duration, use --help option." >&2; exit 0
				    else
						TIMEOUT_DURATION=$2
				    fi
					shift 2;;
				--)	shift; break;;
				esac
			done
		fi
	fi

	mkdir '/tmp/'"$ANALYZER_DIR" 2>/dev/null

	if [[ "$PROPERTY_FILE" == "" ]]; then
		TMP_PROPERTY_FILE="$(mktemp '/tmp/'$ANALYZER_DIR'/PRP_tmp.XXXXXX.prp')"
		printf "CHECK( init(main()), LTL(G ! label(ERROR)) )\n" > "$TMP_PROPERTY_FILE"
		PROPERTY_FILE="$TMP_PROPERTY_FILE"
	else
		TMP_PROPERTY_FILE=""
	fi

    local i=1
    
    while [[ $i -le $iterations || $iterations == "inf" ]]
    do
		echo ""
		if [ "$GENERATE_C_FILE" == true ]; then
		    local C_SOURCE=$(mktemp '/tmp/'$ANALYZER_DIR'/C_CODE_tmp.XXXXXX.c')
		    csmith > "$C_SOURCE"
	        else
		    local C_SOURCE=$INPUT_C_FILE
		    iterations=1
	        fi

	        check_file "$C_SOURCE" "$PROPERTY_FILE"
	        
	        if [ "$STORE_C_FILE" == false ]; then
		    rm -f "$C_SOURCE"
		elif [ "$GENERATE_C_FILE" == true ]; then
		    echo "generated C file is: $C_SOURCE"
	        fi
	
			i=$((i+1))
    done
}

main "${@}"

#removal of always true/false/unknown logs because they are useless ...
#removal of generated PRP file
rm -f "$TMP_PATH/always_*.log" "$TMP_PROPERTY_FILE"
