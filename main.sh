#!/bin/bash

NAME=$0
ANALYZER_DIR=analyzers
STORE_C_FILE=false
STORE_LOGS=false
GENERATE_C_FILE=true
PARAM_REGEX=""
REGEX_MODE="none"
TIMEOUT_DURATION="3m"
TMP_PATH="/tmp/""$ANALYZER_DIR"


red='\e[0;31m'
color='\e[0;32m'
NC='\e[0m' # No Color

help() {
    printf "\nUsage: %s [ options ] \n\n" "$NAME" >&2
    cat >&2 << EOF

    -f <file>, --file <file>
	input C file to verificate.
	<file> must be a correct C source code.
	if entered iterations is set to 1
    
    -c, --store-c-files
	enables storing C source files generated by Csmith.

    -l, --store-log-files
	enables storing error/log files of analyzer stderr output.

    -i <number>, --iterations <number>
	sets <number> of iterations calling verification of generated C file.
	(set to 1 by default)
	if set to inf, program will continue till terminated
	
    -r, --regex | -n, --neg-regex
	finds in analyzers folder only analyzers that match to the given regular expresion.
	format of regular expresion is 'your_regex'
	neg-regex is inverted, runs only analyzers that do not match to given expresion.

    Output of program is printed result od verification by each of called analyzer.
    Format of output is "Analyzer ["name_of_analyzer"] result: "RESULT" logs: "PATH_TO_LOG".
    
    The verification RESULT is TRUE, FALSE, or UNKNOWN. All other information will be printed to error
    log stored in log file (must be nenabled by --store-log-files to)
    
    Memory option (-m64) for 64bit OS is used as default.
    
EOF
    exit 1
}


# @param 1: C source code to be verified 
check_file() {
    local source="$1"
    for analyzer in $( find $ANALYZER_DIR -type f $PARAM_REGEX )
    do
	if [[ $REGEX_MODE == "neg" && "$analyzer" =~ $PARAM_N_REGEX ]] ; then
	  #echo "Analyzer [$analyzer] skipped";
	  continue
	fi   
	
        if [ ! -x "$analyzer" ]; then
            echo "Analyzer is not executable file: $analyzer" >&2; continue
        fi
        
        STDERR="$(mktemp '/tmp/'"$analyzer"'_tmp.XXXXXX.log')"
        
       
        RESULT=$(timeout $TIMEOUT_DURATION ./$analyzer "$source" 2> "$STDERR")
        if [[ "$?" == "124" || "$?" == "137" ]]; then
	    RESULT="${red}TIMEOUT${NC}"
        fi
        
        if [ "$STORE_LOGS" == true ]; then
	    echo -e "Analyzer [$analyzer] result: ${color}$RESULT${NC} logs: $STDERR"
	else
	    echo -e "Analyzer [$analyzer] result: ${color}$RESULT${NC}"
	    rm -f "$STDERR"
        fi
    done
}

regex() {
    re='^[-].*+$'
    if [[ $1 =~ $re ]] ; then
      echo "param regex needs regular expression as next argument" >&2; exit 0
    fi    
}

main() {

iterations=1

    if [ $# -gt 0 ]; then
    
	if [[ "$1" == "--help" || "$1" == "-h" ]]; then
	    help
	    exit 1
	else
	    
	    ARGS=$(getopt -o cli:f:r:n:t: -l "store-c-files,store-log-files,iterations:,file:,regex:,neg-regex:,timeout:" -n "$NAME" -- "$@")
	    if test $? -ne 0; then
		echo "Error in parameters" >&2; exit 0
		exit 0
	    fi
	    
	    eval set -- "$ARGS"
	    
	    while true; do
	      case "$1" in
		-c|--store-c-files)  STORE_C_FILE=true
		    echo "C codes will be stored."; shift;;
		-l|--store-log-files)  STORE_LOGS=true
		    echo "LOGs will be stored."; shift;;
		-f|--file)  
		    INPUT_C_FILE=$2
		    GENERATE_C_FILE=false
		    STORE_C_FILE=true
		    if [[ -s $INPUT_C_FILE && ! -d $INPUT_C_FILE ]]; then
		      echo "C file inputed."  
		    else
		      echo "Wrong input file." >&2; exit 0
		      exit 1
		    fi
		    shift 2;;
		-i|--iterations) 
		      local re='^[0-9]+$'
		      if [[ "$2" == "inf" ]] ; then
			iterations="inf"
			echo "inf"
		      elif ! [[ $2 =~ $re ]] ; then
			echo "Wrong number of iterations or not a number" >&2; exit 0
		      else
			iterations=$2; 
		      fi
		      shift 2;;
		-n|--neg-regex)
		      if [[ "$REGEX_MODE" == "none" ]] ; then
			REGEX_MODE="neg"
			regex "$2" #call of function to handle the regex param.
		      else
			echo "Only one regex mode supported. Use --regex or --neg-regex not both." >&2; exit 0
		      fi
		      PARAM_N_REGEX="$ANALYZER_DIR/$2"
		      shift 2;;
		-r|--regex)
		      if [[ "$REGEX_MODE" == "none" ]] ; then
			REGEX_MODE="norm"
			regex "$2" #call of function to handle the regex param.
		      else
			echo "Only one regex mode supported. Use --regex or --neg-regex not both." >&2; exit 0
		      fi
		      PARAM_REGEX="-regex $ANALYZER_DIR/$2"
		      shift 2;;
		-t|--timeout)
		      local re='^[0-9]+[smhd]|^[0-9]+$'
		      if ! [[ $2 =~ $re ]] ; then
			echo "Wrong timeout duration, use --help option." >&2; exit 0
		      else
			TIMEOUT_DURATION=$2
		      fi
		      shift 2;;
		--) shift; break;;
	      esac
	    done
	  
	fi
    fi
    
    mkdir '/tmp/'"$ANALYZER_DIR" 2>/dev/null
    

    local i=1
    
    while [[ $i -le $iterations || $iterations == "inf" ]]; do
	echo ""
	if [ "$GENERATE_C_FILE" == true ]; then
	    local C_SOURCE=$(mktemp '/tmp/'$ANALYZER_DIR'/C_CODE_tmp.XXXXXX.c')
	    csmith > "$C_SOURCE"
        else
	    local C_SOURCE=$INPUT_C_FILE
	    iterations=1
        fi
        
        check_file "$C_SOURCE"
        
        if [ "$STORE_C_FILE" == false ]; then
	    rm -f "$C_SOURCE"
	elif [ "$GENERATE_C_FILE" == true ]; then
	    echo "generated C file is: $C_SOURCE"
        fi
        
        i=$((i+1))
    done
}

main "${@}"

#removal of always true/false/unknown logs because they are useless ...
rm -f $TMP_PATH/always_*.log
